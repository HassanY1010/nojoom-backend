import { User } from '../models/User.js';
import { pool } from '../config/db.js';
import bcrypt from 'bcryptjs';
import path from 'path';
import fs from 'fs/promises';
import jwt from 'jsonwebtoken';
import { jwtConfig } from '../config/jwt.js';

export const usersController = {
  // ==================== ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ ====================

  // âœ… ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ù…Ø¹ Ø¥Ø±Ø³Ø§Ù„ role ÙÙŠ Ø§Ù„Ø§Ø³ØªØ¬Ø§Ø¨Ø©
  async login(req, res) {
    try {
      const { email, password } = req.body;

      console.log('ğŸ”„ Login attempt for email:', email);

      if (!email || !password) {
        return res.status(400).json({
          error: 'Email and password are required'
        });
      }

      // Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø¨Ø§Ù„Ø¨Ø±ÙŠØ¯ Ø§Ù„Ø¥Ù„ÙƒØªØ±ÙˆÙ†ÙŠ
      const [users] = await pool.execute(
        'SELECT * FROM users WHERE email = ?',
        [email]
      );

      if (users.length === 0) {
        console.log('âŒ User not found for email:', email);
        return res.status(401).json({
          error: 'Invalid email or password'
        });
      }

      const user = users[0];

      console.log('ğŸ” User found:', {
        id: user.id,
        email: user.email,
        username: user.username,
        role: user.role,
        is_banned: user.is_banned
      });

      // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ø­Ø¸Ø±
      if (user.is_banned) {
        console.log('âŒ User is banned:', user.email);
        return res.status(403).json({
          error: 'Account suspended',
          reason: user.ban_reason
        });
      }

      // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
      console.log('ğŸ” Checking password...');

      let isValidPassword = false;

      // âœ… Ù„Ù„Ù…Ø¯ÙŠØ±: ØªØ­Ù‚Ù‚ Ù…Ù† ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± Ø§Ù„ÙˆØ§Ø¶Ø­Ø© Ø£ÙˆÙ„Ø§Ù‹ (Ù„Ù„ØªØ·ÙˆÙŠØ±)
      if (user.role === 'admin' && password === user.password) {
        isValidPassword = true;
        console.log('âœ… Admin plain password matched');
  async createAdminIfNotExists(req, res) {
          try {
            const adminEmail = 'admin@nojoom.com';
            const adminPassword = 'admin123'; // ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± ÙˆØ§Ø¶Ø­Ø©
            const adminUsername = 'admin';

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø¯ÙŠØ± Ù…ÙˆØ¬ÙˆØ¯Ø§Ù‹ Ø¨Ø§Ù„ÙØ¹Ù„
            const [existingAdmins] = await pool.execute(
              'SELECT * FROM users WHERE email = ? OR username = ?',
              [adminEmail, adminUsername]
            );

            if (existingAdmins.length > 0) {
              console.log('âœ… Admin account already exists:', existingAdmins[0].email);
              return res.json({
                message: 'Admin account already exists',
                admin: {
                  id: existingAdmins[0].id,
                  email: existingAdmins[0].email,
                  username: existingAdmins[0].username,
                  role: existingAdmins[0].role,
                  password: 'admin123'
                }
              });
            }

            // âš ï¸ Ø¥Ù†Ø´Ø§Ø¡ Ø­Ø³Ø§Ø¨ Ù…Ø¯ÙŠØ± Ø¨Ø¯ÙˆÙ† ØªØ´ÙÙŠØ± (Ù„Ù„ØªØ·ÙˆÙŠØ± ÙÙ‚Ø·)
            const [result] = await pool.execute(
              `INSERT INTO users (username, email, password, role, email_verified, is_banned) 
         VALUES (?, ?, ?, 'admin', TRUE, FALSE)`,
              [adminUsername, adminEmail, adminPassword]
            );

            console.log('âœ… Admin account created (PLAIN PASSWORD):', {
              id: result.insertId,
              email: adminEmail,
              username: adminUsername
            });

            res.json({
              message: 'Admin account created successfully',
              admin: {
                id: result.insertId,
                email: adminEmail,
                username: adminUsername,
                password: adminPassword,
                note: 'âš ï¸ Password is NOT hashed - for development only!'
              }
            });

          } catch (error) {
            console.error('âŒ Error creating admin account:', error);
            res.status(500).json({
              error: 'Failed to create admin account',
              details: error.message
            });
          }
        },

  // ==================== Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ ====================

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§ØªÙ‡
  async getProfile(req, res) {
          try {
            const { username } = req.params;
            const currentUserId = req.user?.id;

            console.log('ğŸ”„ Fetching profile for:', { username, currentUserId });

            // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            const [users] = await pool.execute(
              `SELECT id, username, email, avatar, bio, social_links, followers_count, following_count, likes_count, views_count, total_watch_time, created_at, role 
         FROM users 
         WHERE username = ?`,
              [username]
            );

            if (users.length === 0) {
              console.log('âŒ User not found:', username);
              return res.status(404).json({ error: 'User not found' });
            }

            const user = users[0];
            console.log('âœ… User found:', user.id, user.username, 'Role:', user.role);

            // Ø§Ù„ØªØ­Ù‚Ù‚ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ ÙŠØªØ§Ø¨Ø¹ Ù‡Ø°Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            let isFollowing = false;
            if (currentUserId) {
              try {
                isFollowing = await User.isFollowing(currentUserId, user.id);
                console.log('ğŸ“Š Following status:', isFollowing);
              } catch (followError) {
                console.error('Error checking follow status:', followError);
                isFollowing = false;
              }
            }

            // Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
            let videos = [];
            try {
              const [videoRows] = await pool.execute(
                `SELECT v.*, 
                  (SELECT COUNT(*) FROM likes WHERE video_id = v.id) as likes,
                  EXISTS(SELECT 1 FROM likes WHERE user_id = ? AND video_id = v.id) as is_liked
           FROM videos v
           WHERE v.user_id = ?
           ORDER BY v.created_at DESC`,
                [currentUserId || 0, user.id]
              );
              videos = videoRows || [];
              console.log('ğŸ¥ Videos found:', videos.length);
            } catch (videoError) {
              console.error('Error fetching videos:', videoError);
              videos = [];
            }

            res.json({
              user,
              videos,
              isFollowing
            });

          } catch (error) {
            console.error('âŒ Get profile error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message,
              code: error.code
            });
          }
        },

  // âœ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ù„Ù Ø§Ù„Ø´Ø®ØµÙŠ
  async updateProfile(req, res) {
          try {
            const userId = req.user.id;
            const { username, bio } = req.body;
            const avatarFile = req.file;

            console.log('ğŸ”„ Updating profile for user:', userId, {
              username,
              bio,
              hasAvatar: !!avatarFile
            });

            let avatarPath = null;

            if (avatarFile) {
              const uploadsDir = path.join(process.cwd(), 'uploads', 'avatars');
              await fs.mkdir(uploadsDir, { recursive: true });

              avatarPath = `/uploads/avatars/${avatarFile.filename}`;
              const finalPath = path.join(uploadsDir, avatarFile.filename);

              await fs.rename(avatarFile.path, finalPath);

              console.log('âœ… Avatar uploaded successfully:', avatarPath);
            }

            const updateData = {
              username: username || null,
              bio: bio || null,
              ...(avatarPath && { avatar: avatarPath })
            };

            const success = await User.updateProfile(userId, updateData);

            if (!success) return res.status(404).json({ error: 'User not found' });

            await User.updateUserStats(userId).catch(err => console.error('Stats update error:', err));

            const user = await User.findById(userId);
            if (!user) return res.status(404).json({ error: 'User not found after update' });

            res.json({
              message: 'Profile updated successfully',
              user: {
                id: user.id,
                username: user.username,
                email: user.email,
                avatar: user.avatar,
                bio: user.bio,
                social_links: user.social_links,
                role: user.role
              }
            });

          } catch (error) {
            console.error('âŒ Update profile error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message
            });
          }
        },

  // âœ… ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±ÙˆØ§Ø¨Ø· Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØ©
  async updateSocialLinks(req, res) {
          try {
            const userId = req.user.id;
            const { social_links } = req.body;

            console.log('ğŸ”„ Updating social links for user:', userId);

            const success = await User.updateSocialLinks(userId, social_links);
            if (!success) return res.status(404).json({ error: 'User not found' });

            const user = await User.findById(userId);

            res.json({
              message: 'Social links updated successfully',
              user: {
                id: user.id,
                username: user.username,
                email: user.email,
                avatar: user.avatar,
                bio: user.bio,
                social_links: user.social_links,
                role: user.role
              }
            });
          } catch (error) {
            console.error('Update social links error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message
            });
          }
        },

  // ==================== Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª ====================

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ø§Ù„ØªÙŠ Ø£Ø¹Ø¬Ø¨ Ø¨Ù‡Ø§ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  async getLikedVideos(req, res) {
          try {
            const currentUserId = req.user.id;
            console.log('ğŸ”„ Fetching liked videos for user:', currentUserId);

            const videos = await User.getLikedVideos(currentUserId);

            console.log('â¤ï¸ Liked videos found:', videos.length);
            res.json({ videos });

          } catch (error) {
            console.error('Get liked videos error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message
            });
          }
        },

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ÙÙŠØ¯ÙŠÙˆÙ‡Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  async getUserVideos(req, res) {
          try {
            const userId = req.user.id;
            const { page = 1, limit = 20 } = req.query;
            const offset = (page - 1) * limit;

            const [videos] = await pool.execute(
              `SELECT v.*, 
                COUNT(DISTINCT l.user_id) as likes,
                EXISTS(SELECT 1 FROM likes WHERE user_id = ? AND video_id = v.id) as is_liked
         FROM videos v
         LEFT JOIN likes l ON v.id = l.video_id
         WHERE v.user_id = ? AND v.deleted_by_admin = FALSE
         GROUP BY v.id
         ORDER BY v.created_at DESC
         LIMIT ? OFFSET ?`,
              [userId, userId, parseInt(limit), offset]
            );

            const [totalCount] = await pool.execute(
              'SELECT COUNT(*) as total FROM videos WHERE user_id = ? AND deleted_by_admin = FALSE',
              [userId]
            );

            res.json({
              success: true,
              data: videos,
              pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total: totalCount[0].total,
                pages: Math.ceil(totalCount[0].total / limit)
              }
            });
          } catch (error) {
            console.error('Get user videos error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message
            });
          }
        },

  // ==================== Ø³Ø¬Ù„ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø© ====================

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø³Ø¬Ù„ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø©
  async getWatchHistory(req, res) {
          try {
            const userId = req.user.id;
            const { page = 1, limit = 20 } = req.query;
            const offset = (page - 1) * limit;

            const [history] = await pool.execute(
              `SELECT 
          wh.*,
          v.id as video_id,
          v.title,
          v.description,
          v.url,
          v.thumbnail,
          v.duration,
          v.views,
          v.likes,
          v.created_at as video_created_at,
          u.id as owner_id,
          u.username as owner_username,
          u.avatar as owner_avatar
         FROM watch_history wh
         JOIN videos v ON wh.video_id = v.id
         JOIN users u ON v.user_id = u.id
         WHERE wh.user_id = ?
         ORDER BY wh.updated_at DESC
         LIMIT ? OFFSET ?`,
              [userId, parseInt(limit), offset]
            );

            const [totalCount] = await pool.execute(
              'SELECT COUNT(*) as total FROM watch_history WHERE user_id = ?',
              [userId]
            );

            res.json({
              success: true,
              data: history,
              pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total: totalCount[0].total,
                pages: Math.ceil(totalCount[0].total / limit)
              }
            });
          } catch (error) {
            console.error('âŒ Get watch history error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to get watch history'
            });
          }
        },

  // âœ… Ø­Ø°Ù Ø¹Ù†ØµØ± Ù…Ù† Ø³Ø¬Ù„ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø©
  async deleteWatchHistoryItem(req, res) {
          try {
            const userId = req.user.id;
            const { videoId } = req.params;

            await pool.execute(
              'DELETE FROM watch_history WHERE user_id = ? AND video_id = ?',
              [userId, videoId]
            );

            res.json({
              success: true,
              message: 'Video removed from watch history'
            });
          } catch (error) {
            console.error('âŒ Delete watch history error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to delete watch history item'
            });
          }
        },

  // âœ… Ù…Ø³Ø­ Ø³Ø¬Ù„ Ø§Ù„Ù…Ø´Ø§Ù‡Ø¯Ø© Ø¨Ø§Ù„ÙƒØ§Ù…Ù„
  async clearWatchHistory(req, res) {
          try {
            const userId = req.user.id;

            await pool.execute(
              'DELETE FROM watch_history WHERE user_id = ?',
              [userId]
            );

            res.json({
              success: true,
              message: 'Watch history cleared successfully'
            });
          } catch (error) {
            console.error('âŒ Clear watch history error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to clear watch history'
            });
          }
        },

  // ==================== ØªÙØ§Ø¹Ù„Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… ====================

  async userInteraction(req, res) {
          try {
            const userId = req.user.id;
            const { videoId, action } = req.body;

            if (!videoId || !action) {
              return res.status(400).json({ error: 'Video ID and action are required' });
            }

            const [videos] = await pool.execute(
              'SELECT id FROM videos WHERE id = ? AND deleted_by_admin = FALSE',
              [videoId]
            );

            if (videos.length === 0) {
              return res.status(404).json({ error: 'Video not found' });
            }

            if (action === 'like') {
              await pool.execute(
                `INSERT INTO likes (user_id, video_id, created_at)
           VALUES (?, ?, NOW())
           ON DUPLICATE KEY UPDATE created_at = NOW()`,
                [userId, videoId]
              );
            } else if (action === 'dislike') {
              await pool.execute(
                'DELETE FROM likes WHERE user_id = ? AND video_id = ?',
                [userId, videoId]
              );
            } else if (action === 'watch') {
              await pool.execute(
                `INSERT INTO watch_history (user_id, video_id, updated_at)
           VALUES (?, ?, NOW())
           ON DUPLICATE KEY UPDATE updated_at = NOW()`,
                [userId, videoId]
              );
            } else {
              return res.status(400).json({ error: 'Invalid action' });
            }

            res.json({ success: true, message: 'Interaction recorded successfully' });

          } catch (error) {
            console.error('User interaction error:', error);
            res.status(500).json({
              success: false,
              error: 'Internal server error',
              details: error.message
            });
          }
        },

  // ==================== Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø© ÙˆØ§Ù„Ù…ØªØ§Ø¨ÙØ¹ÙŠÙ† ====================

  // âœ… Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
  async searchUsers(req, res) {
          try {
            const { q } = req.query;
            const currentUserId = req.user.id;

            if (!q || q.trim().length < 2) {
              return res.json({ users: [] });
            }

            const users = await User.searchUsers(q.trim(), currentUserId);

            res.json({ users });
          } catch (error) {
            console.error('Search users error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message
            });
          }
        },

  // âœ… Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø³ØªØ®Ø¯Ù…
  async followUser(req, res) {
          try {
            const { userId } = req.params;
            const followerId = req.user.id;

            console.log('ğŸ”„ Follow request:', { followerId, targetUserId: userId });

            if (parseInt(userId) === followerId) {
              return res.status(400).json({ error: 'Cannot follow yourself' });
            }

            const success = await User.followUser(followerId, parseInt(userId));

            if (!success) {
              return res.status(400).json({ error: 'Already following this user' });
            }

            // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªÙØ§Ø¹Ù„ ÙÙŠ Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØµÙŠØ©
            try {
              const { recommendationEngine } = await import('../services/recommendationEngine.js');
              await recommendationEngine.recordInteraction({
                userId: followerId,
                targetUserId: parseInt(userId),
                type: 'follow',
                weight: 1.5,
                timestamp: new Date()
              });
            } catch (recError) {
              console.error('Failed to record follow interaction:', recError);
            }

            res.json({ message: 'User followed successfully' });
          } catch (error) {
            console.error('Follow user error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message
            });
          }
        },

  // âœ… Ø¥Ù„ØºØ§Ø¡ Ù…ØªØ§Ø¨Ø¹Ø© Ù…Ø³ØªØ®Ø¯Ù…
  async unfollowUser(req, res) {
          try {
            const { userId } = req.params;
            const followerId = req.user.id;

            console.log('ğŸ”„ Unfollow request:', { followerId, targetUserId: userId });

            const success = await User.unfollowUser(followerId, parseInt(userId));

            if (!success) {
              return res.status(404).json({ error: 'Not following this user' });
            }

            // ØªØ³Ø¬ÙŠÙ„ Ø§Ù„ØªÙØ§Ø¹Ù„ ÙÙŠ Ù†Ø¸Ø§Ù… Ø§Ù„ØªÙˆØµÙŠØ©
            try {
              const { recommendationEngine } = await import('../services/recommendationEngine.js');
              await recommendationEngine.recordInteraction({
                userId: followerId,
                targetUserId: parseInt(userId),
                type: 'unfollow',
                weight: -1.0,
                timestamp: new Date()
              });
            } catch (recError) {
              console.error('Failed to record unfollow interaction:', recError);
            }

            res.json({ message: 'User unfollowed successfully' });
          } catch (error) {
            console.error('Unfollow user error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message
            });
          }
        },

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØ§Ø¨Ø¹ÙŠÙ† Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ÙŠÙ†
  async getFollowers(req, res) {
          try {
            const { userId } = req.params;

            console.log('ğŸ”„ Fetching followers for user:', userId);

            const [followers] = await pool.execute(
              `SELECT u.id, u.username, u.avatar, u.bio, u.created_at
         FROM followers f
         JOIN users u ON f.follower_id = u.id
         WHERE f.following_id = ? AND u.is_banned = FALSE
         ORDER BY f.created_at DESC`,
              [userId]
            );

            res.json({
              success: true,
              followers: followers || []
            });
          } catch (error) {
            console.error('âŒ Get followers error:', error);
            res.status(500).json({
              success: false,
              error: 'Failed to fetch followers'
            });
          }
        },

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØ§Ø¨ÙØ¹ÙŠÙ† Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ÙŠÙ†
  async getFollowing(req, res) {
          try {
            const { userId } = req.params;

            console.log('ğŸ”„ Fetching following for user:', userId);

            const [following] = await pool.execute(
              `SELECT u.id, u.username, u.avatar, u.bio, u.created_at
         FROM followers f
         JOIN users u ON f.following_id = u.id
         WHERE f.follower_id = ? AND u.is_banned = FALSE
         ORDER BY f.created_at DESC`,
              [userId]
            );

            res.json({
              success: true,
              following: following || []
            });
          } catch (error) {
            console.error('âŒ Get following error:', error);
            res.status(500).json({
              success: false,
              error: 'Failed to fetch following'
            });
          }
        },

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø¥Ø¹Ø¬Ø§Ø¨Ø§Øª Ù„Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ÙŠÙ†
  async getLikes(req, res) {
          try {
            const { userId } = req.params;

            console.log('ğŸ”„ Fetching likes for user:', userId);

            const [likes] = await pool.execute(
              `SELECT DISTINCT u.id, u.username, u.avatar, l.created_at
         FROM likes l
         JOIN videos v ON l.video_id = v.id
         JOIN users u ON l.user_id = u.id
         WHERE v.user_id = ? AND u.is_banned = FALSE
         ORDER BY l.created_at DESC`,
              [userId]
            );

            res.json({
              success: true,
              likes: likes || []
            });
          } catch (error) {
            console.error('âŒ Get likes error:', error);
            res.status(500).json({
              success: false,
              error: 'Failed to fetch likes'
            });
          }
        },

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØ§Ø¨Ø¹ÙŠÙ† Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ
  async getMyFollowers(req, res) {
          try {
            const userId = req.user.id;
            const followers = await User.getUserFollowers(userId);
            res.json({ followers });
          } catch (error) {
            console.error('Get followers error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message
            });
          }
        },

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ØªØ§Ø¨ÙØ¹ÙŠÙ† Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø­Ø§Ù„ÙŠ
  async getMyFollowing(req, res) {
          try {
            const userId = req.user.id;
            const following = await User.getUserFollowing(userId);
            res.json({ following });
          } catch (error) {
            console.error('Get following error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message
            });
          }
        },

  // âœ… Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø­Ø§Ù„Ø© Ø§Ù„Ù…ØªØ§Ø¨Ø¹Ø©
  async getFollowStatus(req, res) {
          try {
            const userId = req.user.id;
            const { userId: targetUserId } = req.params;

            const isFollowing = await User.isFollowing(userId, parseInt(targetUserId));

            res.json({
              success: true,
              isFollowing
            });
          } catch (error) {
            console.error('Get follow status error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to get follow status'
            });
          }
        },

  // ==================== Ø§Ù„ØªÙØ¶ÙŠÙ„Ø§Øª ÙˆØ§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ====================

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªÙØ¶ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  async getUserPreferences(req, res) {
          try {
            const userId = req.user.id;
            console.log('ğŸ”„ Getting user preferences for:', userId);

            try {
              const [prefs] = await pool.execute(
                'SELECT preferred_categories, content_weights, excluded_users FROM user_preferences WHERE user_id = ?',
                [userId]
              );

              if (prefs.length > 0) {
                const preferences = {
                  preferred_categories: JSON.parse(prefs[0].preferred_categories || '[]'),
                  content_weights: JSON.parse(prefs[0].content_weights || '{}'),
                  excluded_users: JSON.parse(prefs[0].excluded_users || '[]')
                };

                return res.json({ preferences });
              }
            } catch (dbError) {
              console.error('Error fetching preferences from DB:', dbError);
            }

            const defaultPreferences = {
              preferred_categories: [],
              content_weights: {},
              excluded_users: []
            };

            res.json({
              preferences: defaultPreferences
            });
          } catch (error) {
            console.error('Get user preferences error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message
            });
          }
        },

  // âœ… ØªØ­Ø¯ÙŠØ« ØªÙØ¶ÙŠÙ„Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  async updateUserPreferences(req, res) {
          try {
            const userId = req.user.id;
            const { preferences } = req.body;

            console.log('ğŸ”„ Updating user preferences for:', userId, preferences);

            try {
              await pool.execute(
                `INSERT INTO user_preferences (user_id, preferred_categories, content_weights, excluded_users, updated_at)
           VALUES (?, ?, ?, ?, NOW())
           ON DUPLICATE KEY UPDATE
           preferred_categories = VALUES(preferred_categories),
           content_weights = VALUES(content_weights),
           excluded_users = VALUES(excluded_users),
           updated_at = NOW()`,
                [
                  userId,
                  JSON.stringify(preferences.preferred_categories || []),
                  JSON.stringify(preferences.content_weights || {}),
                  JSON.stringify(preferences.excluded_users || [])
                ]
              );
            } catch (dbError) {
              console.error('Error saving preferences to DB:', dbError);
            }

            res.json({
              message: 'Preferences updated successfully',
              preferences: preferences
            });
          } catch (error) {
            console.error('Update user preferences error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message
            });
          }
        },

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  async getUserStats(req, res) {
          try {
            const userId = req.user.id;

            const [stats] = await pool.execute(
              `SELECT 
           followers_count,
           following_count,
           likes_count,
           views_count,
           total_watch_time,
           (SELECT COUNT(*) FROM videos WHERE user_id = ? AND deleted_by_admin = FALSE) as videos_count
         FROM users 
         WHERE id = ?`,
              [userId, userId]
            );

            res.json({
              success: true,
              data: stats[0]
            });
          } catch (error) {
            console.error('Get user stats error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to get user statistics'
            });
          }
        },

  // âœ… ØªØ­Ø¯ÙŠØ« Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª
  async updateNotificationSettings(req, res) {
          try {
            const userId = req.user.id;
            const { notifications } = req.body;

            await pool.execute(
              `INSERT INTO user_preferences (user_id, notifications, updated_at)
         VALUES (?, ?, NOW())
         ON DUPLICATE KEY UPDATE
         notifications = VALUES(notifications),
         updated_at = NOW()`,
              [userId, notifications !== undefined ? notifications : true]
            );

            res.json({
              success: true,
              message: 'Notification settings updated successfully'
            });
          } catch (error) {
            console.error('Update notification settings error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to update notification settings'
            });
          }
        },

  // ==================== Ø§Ù„Ø¨Ø­Ø« ÙˆØ§Ù„Ø¥ÙƒØªØ´Ø§Ù ====================

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ù‚ØªØ±Ø­ÙŠÙ† Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø©
  async getSuggestedUsers(req, res) {
          try {
            const userId = req.user.id;
            const limit = parseInt(req.query.limit) || 10;

            const [suggestedUsers] = await pool.execute(
              `SELECT u.id, u.username, u.avatar, u.bio, u.followers_count,
                COUNT(DISTINCT f2.follower_id) as mutual_followers
         FROM users u
         LEFT JOIN followers f1 ON u.id = f1.following_id AND f1.follower_id = ?
         LEFT JOIN followers f2 ON u.id = f2.following_id 
                              AND f2.follower_id IN (SELECT following_id FROM followers WHERE follower_id = ?)
         WHERE f1.follower_id IS NULL 
           AND u.id != ? 
           AND u.is_banned = FALSE
         GROUP BY u.id
         ORDER BY mutual_followers DESC, u.followers_count DESC
         LIMIT ?`,
              [userId, userId, userId, limit]
            );

            res.json({
              success: true,
              data: suggestedUsers
            });
          } catch (error) {
            console.error('Get suggested users error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to get suggested users'
            });
          }
        },

  // ==================== Ø§Ù„Ø¥Ø¯Ø§Ø±Ø© ÙˆØ§Ù„Ø£Ù…Ø§Ù† ====================

  // âœ… ØªØºÙŠÙŠØ± ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±
  async changePassword(req, res) {
          try {
            const userId = req.user.id;
            const { currentPassword, newPassword } = req.body;

            const [users] = await pool.execute(
              'SELECT password FROM users WHERE id = ?',
              [userId]
            );

            if (users.length === 0) {
              return res.status(404).json({
                success: false,
                message: 'User not found'
              });
            }

            const isValidPassword = await bcrypt.compare(currentPassword, users[0].password);
            if (!isValidPassword) {
              return res.status(400).json({
                success: false,
                message: 'Current password is incorrect'
              });
            }

            const hashedPassword = await bcrypt.hash(newPassword, 12);
            await pool.execute(
              'UPDATE users SET password = ? WHERE id = ?',
              [hashedPassword, userId]
            );

            res.json({
              success: true,
              message: 'Password changed successfully'
            });
          } catch (error) {
            console.error('Change password error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to change password'
            });
          }
        },

  // âœ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø­Ø³Ø§Ø¨
  async deleteAccount(req, res) {
          try {
            const userId = req.user.id;
            const { password } = req.body;

            const [users] = await pool.execute(
              'SELECT password FROM users WHERE id = ?',
              [userId]
            );

            if (users.length === 0) {
              return res.status(404).json({
                success: false,
                message: 'User not found'
              });
            }

            const isValidPassword = await bcrypt.compare(password, users[0].password);
            if (!isValidPassword) {
              return res.status(400).json({
                success: false,
                message: 'Password is incorrect'
              });
            }

            await pool.execute(
              'UPDATE users SET is_banned = TRUE, email = CONCAT(email, "_deleted_", UUID()) WHERE id = ?',
              [userId]
            );

            res.json({
              success: true,
              message: 'Account deleted successfully'
            });
          } catch (error) {
            console.error('Delete account error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to delete account'
            });
          }
        },

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù†Ø´Ø§Ø· Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  async getUserActivity(req, res) {
          try {
            const userId = req.user.id;
            const { page = 1, limit = 20 } = req.query;
            const offset = (page - 1) * limit;

            const [activities] = await pool.execute(
              `SELECT 'like' as type, l.created_at as timestamp, v.id as video_id, v.title, v.thumbnail,
                u.id as target_user_id, u.username as target_username, u.avatar as target_avatar
         FROM likes l
         JOIN videos v ON l.video_id = v.id
         JOIN users u ON v.user_id = u.id
         WHERE l.user_id = ?
         
         UNION ALL
         
         SELECT 'follow' as type, f.created_at as timestamp, NULL as video_id, NULL as title, NULL as thumbnail,
                u.id as target_user_id, u.username as target_username, u.avatar as target_avatar
         FROM followers f
         JOIN users u ON f.following_id = u.id
         WHERE f.follower_id = ?
         
         ORDER BY timestamp DESC
         LIMIT ? OFFSET ?`,
              [userId, userId, parseInt(limit), offset]
            );

            const [totalCount] = await pool.execute(
              `SELECT (
          (SELECT COUNT(*) FROM likes WHERE user_id = ?) +
          (SELECT COUNT(*) FROM followers WHERE follower_id = ?)
        ) as total`,
              [userId, userId]
            );

            res.json({
              success: true,
              data: activities,
              pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total: totalCount[0].total,
                pages: Math.ceil(totalCount[0].total / limit)
              }
            });
          } catch (error) {
            console.error('Get user activity error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to get user activity'
            });
          }
        },

  // ==================== Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ====================

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø´Ø¹Ø§Ø±Ø§Øª Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…
  async getNotifications(req, res) {
          try {
            const userId = req.user.id;
            const { page = 1, limit = 20 } = req.query;
            const offset = (page - 1) * limit;

            const [notifications] = await pool.execute(
              `SELECT * FROM notifications 
         WHERE user_id = ? 
         ORDER BY created_at DESC
         LIMIT ? OFFSET ?`,
              [userId, parseInt(limit), offset]
            );

            const [totalCount] = await pool.execute(
              'SELECT COUNT(*) as total FROM notifications WHERE user_id = ?',
              [userId]
            );

            res.json({
              success: true,
              data: notifications,
              pagination: {
                page: parseInt(page),
                limit: parseInt(limit),
                total: totalCount[0].total,
                pages: Math.ceil(totalCount[0].total / limit)
              }
            });
          } catch (error) {
            console.error('Get notifications error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to get notifications'
            });
          }
        },

  // âœ… ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø± ÙƒÙ…Ù‚Ø±ÙˆØ¡
  async markNotificationAsRead(req, res) {
          try {
            const userId = req.user.id;
            const { notificationId } = req.params;

            await pool.execute(
              'UPDATE notifications SET is_read = TRUE WHERE id = ? AND user_id = ?',
              [notificationId, userId]
            );

            res.json({
              success: true,
              message: 'Notification marked as read'
            });
          } catch (error) {
            console.error('Mark notification as read error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to mark notification as read'
            });
          }
        },

  // âœ… ØªØ­Ø¯ÙŠØ¯ Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø¥Ø´Ø¹Ø§Ø±Ø§Øª ÙƒÙ…Ù‚Ø±ÙˆØ¡Ø©
  async markAllNotificationsAsRead(req, res) {
          try {
            const userId = req.user.id;

            await pool.execute(
              'UPDATE notifications SET is_read = TRUE WHERE user_id = ? AND is_read = FALSE',
              [userId]
            );

            res.json({
              success: true,
              message: 'All notifications marked as read'
            });
          } catch (error) {
            console.error('Mark all notifications as read error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to mark all notifications as read'
            });
          }
        },

  // âœ… Ø­Ø°Ù Ø¥Ø´Ø¹Ø§Ø±
  async deleteNotification(req, res) {
          try {
            const userId = req.user.id;
            const { notificationId } = req.params;

            await pool.execute(
              'DELETE FROM notifications WHERE id = ? AND user_id = ?',
              [notificationId, userId]
            );

            res.json({
              success: true,
              message: 'Notification deleted successfully'
            });
          } catch (error) {
            console.error('Delete notification error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to delete notification'
            });
          }
        },

  // ==================== Ø§Ù„Ø¨Ù„ÙˆÙƒ ÙˆØ§Ù„Ø­Ø¸Ø± ====================

  // âœ… Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…
  async blockUser(req, res) {
          try {
            const userId = req.user.id;
            const { userId: targetUserId } = req.params;

            if (parseInt(targetUserId) === userId) {
              return res.status(400).json({
                success: false,
                message: 'Cannot block yourself'
              });
            }

            await pool.execute(
              'INSERT IGNORE INTO blocked_users (user_id, blocked_user_id) VALUES (?, ?)',
              [userId, targetUserId]
            );

            res.json({
              success: true,
              message: 'User blocked successfully'
            });
          } catch (error) {
            console.error('Block user error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to block user'
            });
          }
        },

  // âœ… Ø¥Ù„ØºØ§Ø¡ Ø­Ø¸Ø± Ù…Ø³ØªØ®Ø¯Ù…
  async unblockUser(req, res) {
          try {
            const userId = req.user.id;
            const { userId: targetUserId } = req.params;

            await pool.execute(
              'DELETE FROM blocked_users WHERE user_id = ? AND blocked_user_id = ?',
              [userId, targetUserId]
            );

            res.json({
              success: true,
              message: 'User unblocked successfully'
            });
          } catch (error) {
            console.error('Unblock user error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to unblock user'
            });
          }
        },

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø­Ø¸ÙˆØ±ÙŠÙ†
  async getBlockedUsers(req, res) {
          try {
            const userId = req.user.id;

            const [blockedUsers] = await pool.execute(
              `SELECT bu.*, u.username, u.avatar
         FROM blocked_users bu
         JOIN users u ON bu.blocked_user_id = u.id
         WHERE bu.user_id = ?
         ORDER BY bu.created_at DESC`,
              [userId]
            );

            res.json({
              success: true,
              data: blockedUsers
            });
          } catch (error) {
            console.error('Get blocked users error:', error);
            res.status(500).json({
              success: false,
              message: 'Failed to get blocked users'
            });
          }
        },

  // ==================== Ø¯ÙˆØ§Ù„ Ø¥Ø¶Ø§ÙÙŠØ© ====================

  // âœ… Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„ØªÙˆØµÙŠØ©
  async getRecommendationStats(req, res) {
          try {
            const userId = req.user.id;

            const [interactionCount] = await pool.execute(
              'SELECT COUNT(*) as count FROM user_interactions WHERE user_id = ?',
              [userId]
            );

            const [watchHistoryCount] = await pool.execute(
              'SELECT COUNT(*) as count FROM watch_history WHERE user_id = ?',
              [userId]
            );

            res.json({
              interactions: interactionCount[0].count,
              watchHistory: watchHistoryCount[0].count,
              modelUpdated: new Date()
            });
          } catch (error) {
            console.error('Get recommendation stats error:', error);
            res.status(500).json({
              error: 'Internal server error',
              details: error.message
            });
          }
        }
      };